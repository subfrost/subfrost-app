(async () => { console.log(await (await fetch("https://mainnet.subfrost.io/v4/subfrost", {
	  "headers": {
		      "accept": "*/*",
		      "accept-language": "en-US,en;q=0.9",
		      "content-type": "application/json",
		      "priority": "u=1, i",
		      "sec-ch-ua": "\"Google Chrome\";v=\"141\", \"Not?A_Brand\";v=\"8\", \"Chromium\";v=\"141\"",
		      "sec-ch-ua-mobile": "?0",
		      "sec-ch-ua-platform": "\"Linux\"",
		      "sec-fetch-dest": "empty",
		      "sec-fetch-mode": "cors",
		      "sec-fetch-site": "cross-site",
		      "Referer": "http://localhost:3000/"
		    },
	  "body": "{\"id\":1,\"jsonrpc\":\"2.0\",\"method\":\"lua_evalscript\",\"params\":[\"-- Comprehensive balance information for an address (replacement for sandshrew_balances)\\n-- Args: address, protocol_tag (optional, default: \\\"1\\\"), asset_address (optional)\\n\\nlocal address = args[1]\\nlocal protocol_tag = args[2] or \\\"1\\\"\\nlocal asset_address = args[3]\\n\\n-- Determine which addresses to query\\nlocal addresses = {address}\\nif asset_address then\\n    table.insert(addresses, asset_address)\\nend\\n\\n-- Remove duplicates\\nlocal unique_addresses = {}\\nlocal seen = {}\\nfor _, addr in ipairs(addresses) do\\n    if not seen[addr] then\\n        seen[addr] = true\\n        table.insert(unique_addresses, addr)\\n    end\\nend\\n\\n-- Get ord and metashrew heights\\nlocal ord_height = _RPC.ord_blockheight() or 0\\nlocal metashrew_height_str = _RPC.metashrew_height() or \\\"0\\\"\\nlocal metashrew_height = tonumber(metashrew_height_str) or 0\\nlocal max_indexed_height = math.max(ord_height, metashrew_height)\\n\\n-- Collect results for all addresses\\nlocal all_spendable = {}\\nlocal all_assets = {}\\nlocal all_pending = {}\\n\\nfor _, addr in ipairs(unique_addresses) do\\n    -- Get UTXOs\\n    local utxos = _RPC.esplora_addressutxo(addr) or {}\\n    \\n    -- Get protorunes/alkanes data\\n    local protorunes = _RPC.alkanes_protorunesbyaddress({\\n        address = addr,\\n        protocolTag = protocol_tag\\n    }) or {}\\n    \\n    -- Get ord outputs (inscriptions and runes)\\n    local ord_outputs = _RPC.ord_outputs(addr) or {}\\n    \\n    -- Build lookup maps\\n    local runes_map = {}\\n    if protorunes.outpoints then\\n        for _, outpoint in ipairs(protorunes.outpoints) do\\n            if outpoint.outpoint and outpoint.runes then\\n                local txid = outpoint.outpoint.txid\\n                local vout = outpoint.outpoint.vout\\n                -- Reverse txid for key (to match esplora format)\\n                local key = txid .. \\\":\\\" .. vout\\n                runes_map[key] = outpoint.runes\\n            end\\n        end\\n    end\\n    \\n    local ord_outputs_map = {}\\n    for _, output in ipairs(ord_outputs) do\\n        if output.outpoint then\\n            ord_outputs_map[output.outpoint] = {\\n                inscriptions = output.inscriptions or {},\\n                ord_runes = output.runes or {}\\n            }\\n        end\\n    end\\n    \\n    -- Process each UTXO\\n    for _, utxo in ipairs(utxos) do\\n        local txid = utxo.txid\\n        local vout = utxo.vout\\n        local value = utxo.value\\n        local key = txid .. \\\":\\\" .. vout\\n        \\n        -- Get height if available\\n        local height = nil\\n        if utxo.status and utxo.status.block_height then\\n            height = utxo.status.block_height\\n        end\\n        \\n        -- Build UTXO entry\\n        local utxo_entry = {\\n            outpoint = key,\\n            value = value\\n        }\\n        \\n        if height then\\n            utxo_entry.height = height\\n        end\\n        \\n        -- Add runes if present\\n        if runes_map[key] then\\n            utxo_entry.runes = runes_map[key]\\n        end\\n        \\n        -- Add inscriptions and ord_runes if present\\n        if ord_outputs_map[key] then\\n            if #ord_outputs_map[key].inscriptions > 0 then\\n                utxo_entry.inscriptions = ord_outputs_map[key].inscriptions\\n            end\\n            if next(ord_outputs_map[key].ord_runes) ~= nil then\\n                utxo_entry.ord_runes = ord_outputs_map[key].ord_runes\\n            end\\n        end\\n        \\n        -- Categorize UTXO\\n        local has_assets = (utxo_entry.runes and #utxo_entry.runes > 0) or\\n                          (utxo_entry.inscriptions and #utxo_entry.inscriptions > 0) or\\n                          (utxo_entry.ord_runes and next(utxo_entry.ord_runes) ~= nil)\\n        \\n        local is_confirmed = height and height <= max_indexed_height\\n        \\n        if not is_confirmed then\\n            table.insert(all_pending, utxo_entry)\\n        elseif has_assets then\\n            table.insert(all_assets, utxo_entry)\\n        else\\n            table.insert(all_spendable, utxo_entry)\\n        end\\n    end\\nend\\n\\n-- Return result in sandshrew_balances format\\nreturn {\\n    spendable = all_spendable,\\n    assets = all_assets,\\n    pending = all_pending,\\n    ordHeight = ord_height,\\n    metashrewHeight = metashrew_height\\n}\\n\",\"bc1pu8pmf7t49sd38kma3ymhmuakhswv633s587yvp8zukp9dwuxynrsxgn9kj\",\"1\"]}",
	    "method": "POST"
})).json()); })().catch((err) => console.error(err));

/**
 * Alkanes-RS Wallet Integration
 * 
 * Integrates alkanes-rs ts-sdk as a keystore backend for @alkanes/ts-sdk
 * Provides encrypted keystore management, PSBT signing, and regtest support
 */

import type { Network } from '@alkanes/ts-sdk';
import * as bitcoin from 'bitcoinjs-lib';
import {
  generateMnemonic,
  validateMnemonic,
  createBrowserKeystore,
  encryptBrowserKeystore,
  decryptBrowserKeystore,
  serializeEncryptedKeystore,
  parseEncryptedKeystore,
  type BrowserKeystore,
  type EncryptedBrowserKeystore,
} from './browser-keystore';

// ECC library initialization state
let eccInitialized = false;

async function initEccLib() {
  if (eccInitialized) return;
  
  const ecc = await import('@bitcoinerlab/secp256k1');
  bitcoin.initEccLib(ecc);
  eccInitialized = true;
}

// These will be available after linking @alkanes/ts-sdk
// import { 
//   createKeystore, 
//   unlockKeystore, 
//   createWallet,
//   createProvider as createAlkanesProvider,
//   type AlkanesProvider,
//   type AlkanesWallet,
//   type Keystore,
// } from '@alkanes/ts-sdk';
// import init, * as wasm from '@alkanes/ts-sdk/wasm';

// Type definitions (matching alkanes-rs ts-sdk types)
export type Keystore = {
  mnemonic: string;
  masterFingerprint: string;
  accountXpub: string;
  hdPaths: Record<string, any>;
  network: string;
  createdAt: number;
};

export type EncryptedKeystore = {
  encrypted_mnemonic: string;
  master_fingerprint: string;
  created_at: number;
  version: string;
  pbkdf2_params: {
    salt: string;
    nonce?: string;
    iterations: number;
    algorithm?: string;
  };
  account_xpub: string;
  hd_paths: Record<string, string>;
};

export type AlkanesWalletInstance = {
  getMnemonic(): string;
  getReceivingAddress(index?: number): string;
  getChangeAddress(index?: number): string;
  deriveAddress(type: 'p2wpkh' | 'p2tr', index: number, change: number): { address: string; path: string; publicKey: string };
  signPsbt(psbtBase64: string): string;
  signMessage(message: string, index?: number): string;
  getKeystore(): Keystore;
};

/**
 * WASM module state
 */
let wasmInitialized = false;
let wasmModule: any = null;

/**
 * Initialize WASM module (call once at app startup)
 * Currently disabled to avoid node:crypto issues
 */
export async function initAlkanesWasm() {
  if (wasmInitialized) {
    return wasmModule;
  }

  // Skip WASM initialization for now - using browser-only implementation
  wasmInitialized = true;
  wasmModule = {};
  
  if (typeof window !== 'undefined' && process.env.NODE_ENV === 'development') {
    console.log('âœ… Alkanes wallet ready (browser-only mode)');
  }
  
  return wasmModule;
}

/**
 * Get network type for alkanes SDK
 */
function getAlkanesNetwork(network: Network): 'mainnet' | 'testnet' | 'regtest' | 'signet' {
  switch (network) {
    case 'mainnet':
      return 'mainnet';
    case 'testnet':
      return 'testnet';
    case 'regtest':
      return 'regtest';
    case 'signet':
      return 'signet';
    default:
      return 'mainnet';
  }
}

/**
 * Get bitcoinjs-lib network
 */
function getBitcoinJsNetwork(network: Network): bitcoin.Network {
  switch (network) {
    case 'mainnet':
      return bitcoin.networks.bitcoin;
    case 'testnet':
      return bitcoin.networks.testnet;
    case 'regtest':
      return bitcoin.networks.regtest;
    default:
      return bitcoin.networks.bitcoin;
  }
}

/**
 * Create a new encrypted keystore
 * 
 * @param password - Encryption password (min 8 characters)
 * @param network - Bitcoin network
 * @param wordCount - Mnemonic word count (12, 15, 18, 21, or 24)
 * @returns Encrypted keystore JSON and mnemonic
 */
export async function createAlkanesKeystore(
  password: string,
  network: Network = 'mainnet',
  wordCount: 12 | 15 | 18 | 21 | 24 = 12
): Promise<{ keystore: string; mnemonic: string }> {
  // Use browser-only implementation to avoid node:crypto issues
  const mnemonic = generateMnemonic(wordCount);
  const keystore = createBrowserKeystore(mnemonic, network);
  const encrypted = await encryptBrowserKeystore(keystore, password);
  
  return {
    keystore: serializeEncryptedKeystore(encrypted),
    mnemonic,
  };
}

/**
 * Unlock an encrypted keystore
 * 
 * @param keystoreJson - Encrypted keystore JSON string
 * @param password - Decryption password
 * @returns Decrypted keystore object
 */
export async function unlockAlkanesKeystore(
  keystoreJson: string,
  password: string,
  network: Network = 'mainnet'
): Promise<Keystore> {
  // Use browser-only implementation to avoid node:crypto issues
  const encrypted = parseEncryptedKeystore(keystoreJson);
  const decrypted = await decryptBrowserKeystore(encrypted, password, network);
  
  return {
    mnemonic: decrypted.mnemonic,
    masterFingerprint: decrypted.masterFingerprint,
    accountXpub: decrypted.accountXpub,
    hdPaths: {},
    network: decrypted.network,
    createdAt: decrypted.createdAt,
  };
}

/**
 * Create an Alkanes wallet from keystore
 * 
 * @param keystore - Decrypted keystore object
 * @returns Alkanes wallet instance
 */
export async function createAlkanesWallet(
  keystore: Keystore
): Promise<AlkanesWalletInstance> {
  // Initialize ECC library for bitcoinjs-lib
  await initEccLib();
  
  // Use bitcoinjs-lib directly for wallet creation (browser-compatible)
  const bip39 = await import('bip39');
  const BIP32Factory = (await import('bip32')).default;
  const ecc = await import('@bitcoinerlab/secp256k1');
  const bip32 = BIP32Factory(ecc);
  
  const seed = bip39.mnemonicToSeedSync(keystore.mnemonic);
  const network = getBitcoinJsNetwork(keystore.network as Network);
  const root = bip32.fromSeed(seed, network);
  const accountPath = "m/84'/0'/0'";
  const accountNode = root.derivePath(accountPath);
  
  return {
    getMnemonic: () => keystore.mnemonic,
    getReceivingAddress: (index = 0) => {
      const node = accountNode.derive(0).derive(index);
      const { address } = bitcoin.payments.p2wpkh({ pubkey: node.publicKey, network });
      return address!;
    },
    getChangeAddress: (index = 0) => {
      const node = accountNode.derive(1).derive(index);
      const { address } = bitcoin.payments.p2wpkh({ pubkey: node.publicKey, network });
      return address!;
    },
    deriveAddress: (type, index, change) => {
      const node = accountNode.derive(change).derive(index);
      const pubkey = node.publicKey;
      let address: string;
      
      if (type === 'p2tr') {
        const internalPubkey = pubkey.slice(1, 33);
        const payment = bitcoin.payments.p2tr({ internalPubkey, network });
        address = payment.address!;
      } else {
        const payment = bitcoin.payments.p2wpkh({ pubkey, network });
        address = payment.address!;
      }
      
      return {
        address,
        path: `${accountPath}/${change}/${index}`,
        publicKey: pubkey.toString('hex'),
      };
    },
    signPsbt: (psbtBase64: string) => {
      // TODO: Implement PSBT signing with bitcoinjs-lib
      return psbtBase64;
    },
    signMessage: (message: string, index = 0) => {
      // TODO: Implement message signing
      return '';
    },
    getKeystore: () => keystore,
  };
}

/**
 * Create an Alkanes provider for @alkanes/ts-sdk
 * 
 * @param network - Bitcoin network
 * @param rpcUrl - Optional Bitcoin Core RPC URL (defaults based on network)
 * @returns Alkanes provider compatible with @alkanes/ts-sdk
 */
export async function createAlkanesProvider(
  network: Network,
  rpcUrl?: string
) {
  // For now, return a simple provider that uses the default @alkanes/ts-sdk Provider
  // This avoids importing the alkanes SDK which has node:crypto issues
  const { Provider } = await import('@alkanes/ts-sdk');
  
  const defaultUrls: Record<Network, string> = {
    mainnet: 'https://api.subfrost.com',
    testnet: 'https://testnet-api.subfrost.com',
    regtest: 'http://localhost:18443',
    signet: 'https://signet-api.subfrost.com',
    oylnet: 'https://oylnet-api.subfrost.com',
  };
  
  const url = rpcUrl || defaultUrls[network] || defaultUrls.mainnet;
  const networkType = getAlkanesNetwork(network);
  const bitcoinNetwork = getBitcoinJsNetwork(network);
  
  return new Provider({
    version: 'v2',
    network: bitcoinNetwork,
    networkType,
    url,
    projectId: network === 'oylnet' ? 'regtest' : 'subfrost',
  });
}

/**
 * Complete wallet setup flow
 * 
 * Creates a new wallet with encrypted keystore and provider
 * 
 * @param password - Encryption password
 * @param network - Bitcoin network
 * @returns Wallet, keystore JSON, mnemonic, and provider
 */
export async function setupAlkanesWallet(
  password: string,
  network: Network = 'mainnet'
) {
  // Create keystore
  const { keystore: keystoreJson, mnemonic } = await createAlkanesKeystore(
    password,
    network
  );
  
  // Unlock keystore
  const keystore = await unlockAlkanesKeystore(keystoreJson, password);
  
  // Create wallet
  const wallet = await createAlkanesWallet(keystore);
  
  // Create provider
  const provider = await createAlkanesProvider(network);
  
  // Get addresses
  const address = wallet.getReceivingAddress(0);
  const taprootAddress = wallet.deriveAddress('p2tr', 0, 0).address;
  
  return {
    wallet,
    provider,
    keystore: keystoreJson,
    mnemonic,
    address,        // P2WPKH address
    taprootAddress, // P2TR address
  };
}

/**
 * Restore wallet from encrypted keystore
 * 
 * @param keystoreJson - Encrypted keystore JSON
 * @param password - Decryption password
 * @param network - Bitcoin network
 * @returns Wallet and provider
 */
export async function restoreAlkanesWallet(
  keystoreJson: string,
  password: string,
  network: Network = 'mainnet'
) {
  // Unlock keystore
  const keystore = await unlockAlkanesKeystore(keystoreJson, password);
  
  // Create wallet
  const wallet = await createAlkanesWallet(keystore);
  
  // Create provider
  const provider = await createAlkanesProvider(network);
  
  // Get addresses
  const address = wallet.getReceivingAddress(0);
  const taprootAddress = wallet.deriveAddress('p2tr', 0, 0).address;
  
  return {
    wallet,
    provider,
    address,
    taprootAddress,
  };
}

/**
 * Sign a PSBT with Alkanes wallet
 * 
 * @param wallet - Alkanes wallet instance
 * @param psbtBase64 - PSBT in base64 format
 * @returns Signed PSBT in base64 format
 */
export function signPsbtWithAlkanes(
  wallet: AlkanesWalletInstance,
  psbtBase64: string
): string {
  return wallet.signPsbt(psbtBase64);
}

/**
 * Get alkane token balance
 * 
 * @param provider - Alkanes provider
 * @param address - Bitcoin address
 * @param alkaneId - Alkane ID (block:tx)
 * @returns Balance information
 */
export async function getAlkaneBalance(
  provider: any,
  address: string,
  alkaneId: { block: number; tx: number }
) {
  return provider.getAlkaneBalance(address, alkaneId);
}

/**
 * Storage keys for keystore
 */
export const STORAGE_KEYS = {
  ENCRYPTED_KEYSTORE: 'alkanes_encrypted_keystore',
  WALLET_NETWORK: 'alkanes_wallet_network',
} as const;

/**
 * Save encrypted keystore to storage
 * 
 * @param keystoreJson - Encrypted keystore JSON
 * @param network - Bitcoin network
 */
export function saveKeystoreToStorage(keystoreJson: string, network: Network) {
  if (typeof window === 'undefined') return;
  
  try {
    localStorage.setItem(STORAGE_KEYS.ENCRYPTED_KEYSTORE, keystoreJson);
    localStorage.setItem(STORAGE_KEYS.WALLET_NETWORK, network);
  } catch (error) {
    console.error('Failed to save keystore to storage:', error);
  }
}

/**
 * Load encrypted keystore from storage
 * 
 * @returns Encrypted keystore JSON and network, or null if not found
 */
export function loadKeystoreFromStorage(): { keystore: string; network: Network } | null {
  if (typeof window === 'undefined') return null;
  
  try {
    const keystore = localStorage.getItem(STORAGE_KEYS.ENCRYPTED_KEYSTORE);
    const network = localStorage.getItem(STORAGE_KEYS.WALLET_NETWORK) as Network;
    
    if (keystore && network) {
      return { keystore, network };
    }
  } catch (error) {
    console.error('Failed to load keystore from storage:', error);
  }
  
  return null;
}

/**
 * Clear keystore from storage
 */
export function clearKeystoreFromStorage() {
  if (typeof window === 'undefined') return;
  
  try {
    localStorage.removeItem(STORAGE_KEYS.ENCRYPTED_KEYSTORE);
    localStorage.removeItem(STORAGE_KEYS.WALLET_NETWORK);
  } catch (error) {
    console.error('Failed to clear keystore from storage:', error);
  }
}

/**
 * Check if alkanes wallet is available in storage
 */
export function hasStoredKeystore(): boolean {
  if (typeof window === 'undefined') return false;
  return !!localStorage.getItem(STORAGE_KEYS.ENCRYPTED_KEYSTORE);
}

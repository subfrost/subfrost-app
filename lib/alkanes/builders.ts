/**
 * Protostone & Input Requirement Builders
 *
 * Pure functions that construct the protostone and inputRequirements strings
 * consumed by `alkanesExecuteWithStrings`. Zero external dependencies.
 *
 * Single source of truth — imported by React hooks, integration tests, and
 * unit tests. Previously duplicated across every mutation hook.
 *
 * @see lib/alkanes/extendedProvider.ts — calls these builders' output
 * @see __tests__/sdk/e2e-swap-flow.test.ts — integration tests for each flow
 */

import {
  FACTORY_SWAP_OPCODE,
  FRBTC_WRAP_OPCODE,
  FRBTC_UNWRAP_OPCODE,
  POOL_OPCODES,
} from './constants';

// ---------------------------------------------------------------------------
// Swap
// ---------------------------------------------------------------------------

/**
 * Build protostone for AMM swap via factory opcode 13 (SwapExactTokensForTokens).
 *
 * Returns ONLY the factory cellpack protostone (no manual edict).
 * The edict that delivers sell tokens is auto-generated by the SDK from
 * `inputRequirements`. The SDK creates p0 (edict → p1) and this becomes p1.
 *
 * Factory opcode 13 format:
 *   [factory_block,factory_tx,13,path_len,sell_block,sell_tx,buy_block,buy_tx,amount_in,amount_out_min,deadline]
 */
export function buildSwapProtostone(params: {
  factoryId: string;
  sellTokenId: string;
  buyTokenId: string;
  sellAmount: string;
  minOutput: string;
  deadline: string;
  pointer?: string;
  refund?: string;
}): string {
  const {
    factoryId,
    sellTokenId,
    buyTokenId,
    sellAmount,
    minOutput,
    deadline,
    pointer = 'v0',
    refund = 'v0',
  } = params;

  const [sellBlock, sellTx] = sellTokenId.split(':');
  const [buyBlock, buyTx] = buyTokenId.split(':');
  const [factoryBlock, factoryTx] = factoryId.split(':');

  const cellpack = [
    factoryBlock,
    factoryTx,
    FACTORY_SWAP_OPCODE,
    2, // path_len (always 2 for direct swap: sell → buy)
    sellBlock,
    sellTx,
    buyBlock,
    buyTx,
    sellAmount,
    minOutput,
    deadline,
  ].join(',');

  return `[${cellpack}]:${pointer}:${refund}`;
}

/**
 * Build input requirements for swap.
 * Format: "B:amount" for bitcoin, "block:tx:amount" for alkanes.
 */
export function buildSwapInputRequirements(params: {
  bitcoinAmount?: string;
  alkaneInputs?: Array<{ alkaneId: string; amount: string }>;
}): string {
  const parts: string[] = [];

  if (params.bitcoinAmount && params.bitcoinAmount !== '0') {
    parts.push(`B:${params.bitcoinAmount}`);
  }

  if (params.alkaneInputs) {
    for (const input of params.alkaneInputs) {
      const [block, tx] = input.alkaneId.split(':');
      parts.push(`${block}:${tx}:${input.amount}`);
    }
  }

  return parts.join(',');
}

// ---------------------------------------------------------------------------
// Wrap (BTC → frBTC)
// ---------------------------------------------------------------------------

/**
 * Build protostone for BTC → frBTC wrap operation.
 *
 * Output ordering matches CLI wrap_btc.rs:
 *   - Output 0 (v0): signer address (receives BTC via B:amount:v0)
 *   - Output 1 (v1): user address (receives minted frBTC via pointer=v1)
 */
export function buildWrapProtostone(params: {
  frbtcId: string;
}): string {
  const [frbtcBlock, frbtcTx] = params.frbtcId.split(':');
  const cellpack = `${frbtcBlock},${frbtcTx},${FRBTC_WRAP_OPCODE}`;
  return `[${cellpack}]:v1:v1`;
}

// ---------------------------------------------------------------------------
// Unwrap (frBTC → BTC)
// ---------------------------------------------------------------------------

/**
 * Build protostone for frBTC → BTC unwrap operation.
 */
export function buildUnwrapProtostone(params: {
  frbtcId: string;
  pointer?: string;
  refund?: string;
}): string {
  const { frbtcId, pointer = 'v1', refund = 'v1' } = params;
  const [frbtcBlock, frbtcTx] = frbtcId.split(':');
  const cellpack = [frbtcBlock, frbtcTx, FRBTC_UNWRAP_OPCODE].join(',');
  return `[${cellpack}]:${pointer}:${refund}`;
}

/**
 * Build input requirements for unwrap.
 * Format: "block:tx:amount"
 */
export function buildUnwrapInputRequirements(params: {
  frbtcId: string;
  amount: string;
}): string {
  const [block, tx] = params.frbtcId.split(':');
  return `${block}:${tx}:${params.amount}`;
}

// ---------------------------------------------------------------------------
// Wrap + Swap (BTC → Token, atomic)
// ---------------------------------------------------------------------------

/**
 * Build combined wrap+swap protostone.
 *
 * Two protostones chained:
 *   p0: Wrap (frBTC contract opcode 77) with pointer=p1
 *   p1: Swap (factory opcode 13)
 *
 * NOTE: This atomic approach is DEPRECATED — pointer=pN doesn't work for
 * cellpack chaining. SwapShell uses two separate txs instead.
 * Kept for reference and integration test coverage.
 */
export function buildWrapSwapProtostone(params: {
  frbtcId: string;
  factoryId: string;
  buyTokenId: string;
  frbtcAmount: string;
  minOutput: string;
  deadline: string;
}): string {
  const { frbtcId, factoryId, buyTokenId, frbtcAmount, minOutput, deadline } = params;
  const [frbtcBlock, frbtcTx] = frbtcId.split(':');
  const [factoryBlock, factoryTx] = factoryId.split(':');
  const [buyBlock, buyTx] = buyTokenId.split(':');

  const blockNum = parseInt(frbtcBlock, 10);
  const txNum = parseInt(frbtcTx, 10);
  const wrapCellpack = `${blockNum},${txNum},${FRBTC_WRAP_OPCODE}`;
  const p0 = `[${wrapCellpack}]:p1:v0`;

  const swapCellpack = [
    factoryBlock,
    factoryTx,
    FACTORY_SWAP_OPCODE,
    2,
    frbtcBlock,
    frbtcTx,
    buyBlock,
    buyTx,
    frbtcAmount,
    minOutput,
    deadline,
  ].join(',');
  const p1 = `[${swapCellpack}]:v0:v0`;

  return `${p0},${p1}`;
}

// ---------------------------------------------------------------------------
// Swap + Unwrap (Token → BTC, atomic)
// ---------------------------------------------------------------------------

/**
 * Build combined swap+unwrap protostone.
 *
 * Returns TWO cellpack protostones (no manual edict). The SDK auto-generates
 * the edict at p0 from inputRequirements:
 *   p0: SDK auto-edict → sends sell tokens to p1
 *   p1: Swap cellpack → pointer=p2 forwards frBTC
 *   p2: Unwrap cellpack → outputs BTC to v0
 */
export function buildSwapUnwrapProtostone(params: {
  sellTokenId: string;
  sellAmount: string;
  frbtcId: string;
  factoryId: string;
  minFrbtcOutput: string;
  deadline: string;
}): string {
  const { sellTokenId, sellAmount, frbtcId, factoryId, minFrbtcOutput, deadline } = params;

  const [sellBlock, sellTx] = sellTokenId.split(':');
  const [frbtcBlock, frbtcTx] = frbtcId.split(':');
  const [factoryBlock, factoryTx] = factoryId.split(':');

  const swapCellpack = [
    factoryBlock,
    factoryTx,
    FACTORY_SWAP_OPCODE,
    2,
    sellBlock,
    sellTx,
    frbtcBlock,
    frbtcTx,
    sellAmount,
    minFrbtcOutput,
    deadline,
  ].join(',');
  const p1 = `[${swapCellpack}]:p2:v0`;

  const unwrapCellpack = [frbtcBlock, frbtcTx, FRBTC_UNWRAP_OPCODE].join(',');
  const p2 = `[${unwrapCellpack}]:v0:v0`;

  return `${p1},${p2}`;
}

// ---------------------------------------------------------------------------
// Transfer (alkane send)
// ---------------------------------------------------------------------------

/**
 * Build edict protostone for alkane transfer.
 *
 * Edict-based splitting (per SDK convention):
 *   [block:tx:amount:v1]:v0:v0
 *   - Edict sends exact amount to v1 (recipient)
 *   - Pointer v0 receives unedicted remainder (sender change)
 *   - Refund v0 receives tokens on failure
 */
export function buildTransferProtostone(params: {
  alkaneId: string;
  amount: string;
}): string {
  const [block, tx] = params.alkaneId.split(':');
  return `[${block}:${tx}:${params.amount}:v1]:v0:v0`;
}

/**
 * Build input requirements for alkane transfer.
 * Format: "block:tx:amount"
 */
export function buildTransferInputRequirements(params: {
  alkaneId: string;
  amount: string;
}): string {
  const [block, tx] = params.alkaneId.split(':');
  return `${block}:${tx}:${params.amount}`;
}

// ---------------------------------------------------------------------------
// Add Liquidity
// ---------------------------------------------------------------------------

/**
 * Build protostone for CreateNewPool via factory opcode 1.
 *
 * Two-protostone pattern:
 *   p0: Two edicts transferring token0 AND token1 to p1
 *   p1: Cellpack calling factory with opcode 1
 */
export function buildCreateNewPoolProtostone(params: {
  factoryId: string;
  token0Id: string;
  token1Id: string;
  amount0: string;
  amount1: string;
}): string {
  const [factoryBlock, factoryTx] = params.factoryId.split(':');
  const [token0Block, token0Tx] = params.token0Id.split(':');
  const [token1Block, token1Tx] = params.token1Id.split(':');

  const edict0 = `[${token0Block}:${token0Tx}:${params.amount0}:p1]`;
  const edict1 = `[${token1Block}:${token1Tx}:${params.amount1}:p1]`;
  const p0 = `${edict0}:${edict1}:v0:v0`;

  const cellpack = [
    factoryBlock, factoryTx,
    1, // CreateNewPool
    token0Block, token0Tx,
    token1Block, token1Tx,
    params.amount0, params.amount1,
  ].join(',');
  const p1 = `[${cellpack}]:v0:v0`;

  return `${p0},${p1}`;
}

/**
 * Build protostone for AddLiquidity to existing pool.
 *
 * Two-protostone pattern:
 *   p0: Two edicts transferring token0 AND token1 to p1
 *   p1: Cellpack calling pool directly with opcode 1 (AddLiquidity)
 */
export function buildAddLiquidityToPoolProtostone(params: {
  poolId: { block: string | number; tx: string | number };
  token0Id: string;
  token1Id: string;
  amount0: string;
  amount1: string;
}): string {
  const poolBlock = params.poolId.block.toString();
  const poolTx = params.poolId.tx.toString();
  const [token0Block, token0Tx] = params.token0Id.split(':');
  const [token1Block, token1Tx] = params.token1Id.split(':');

  const edict0 = `[${token0Block}:${token0Tx}:${params.amount0}:p1]`;
  const edict1 = `[${token1Block}:${token1Tx}:${params.amount1}:p1]`;
  const p0 = `${edict0}:${edict1}:v0:v0`;

  const cellpack = [
    poolBlock, poolTx,
    POOL_OPCODES.AddLiquidity,
  ].join(',');
  const p1 = `[${cellpack}]:v0:v0`;

  return `${p0},${p1}`;
}

/**
 * Build input requirements for AddLiquidity.
 * Format: "block0:tx0:amount0,block1:tx1:amount1"
 */
export function buildAddLiquidityInputRequirements(params: {
  token0Id: string;
  token1Id: string;
  amount0: string;
  amount1: string;
}): string {
  const [block0, tx0] = params.token0Id.split(':');
  const [block1, tx1] = params.token1Id.split(':');
  return `${block0}:${tx0}:${params.amount0},${block1}:${tx1}:${params.amount1}`;
}

// ---------------------------------------------------------------------------
// Remove Liquidity
// ---------------------------------------------------------------------------

/**
 * Build protostone for RemoveLiquidity (burn LP tokens).
 *
 * Two-protostone pattern:
 *   p0: Edict transferring LP tokens to p1
 *   p1: Cellpack calling pool with opcode 2 (RemoveLiquidity)
 *
 * The LP token ID IS the pool ID.
 */
export function buildRemoveLiquidityProtostone(params: {
  lpTokenId: string;
  lpAmount: string;
  minAmount0: string;
  minAmount1: string;
  deadline: string;
  pointer?: string;
  refund?: string;
}): string {
  const {
    lpTokenId,
    lpAmount,
    minAmount0,
    minAmount1,
    deadline,
    pointer = 'v0',
    refund = 'v0',
  } = params;

  const [lpBlock, lpTx] = lpTokenId.split(':');

  const edict = `[${lpBlock}:${lpTx}:${lpAmount}:p1]`;
  const p0 = `${edict}:${pointer}:${refund}`;

  const cellpack = [
    lpBlock,
    lpTx,
    POOL_OPCODES.RemoveLiquidity,
    minAmount0,
    minAmount1,
    deadline,
  ].join(',');
  const p1 = `[${cellpack}]:${pointer}:${refund}`;

  return `${p0},${p1}`;
}

/**
 * Build input requirements for RemoveLiquidity.
 * Format: "lp_block:lp_tx:lpAmount"
 */
export function buildRemoveLiquidityInputRequirements(params: {
  lpTokenId: string;
  lpAmount: string;
}): string {
  const [block, tx] = params.lpTokenId.split(':');
  return `${block}:${tx}:${params.lpAmount}`;
}
